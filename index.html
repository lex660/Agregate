// Cloudflare Worker для агрегации данных исламских рассрочек
// С автоматическим парсингом данных с сайтов банков
// Требует: Cloudflare KV namespace с именем "BANKS_DATA"
// VERSION: 2.0 - Fixed Al-Baraka regex pattern ([\d.] instead of [\\d.])

// ============================================
// КОНФИГУРАЦИЯ ИСТОЧНИКОВ ДАННЫХ (Полностью динамическая - из KV)
// ============================================
// Все банки управляются через админ-панель, нет дефолтных источников

// ============================================
// АВТОМАТИЧЕСКИЙ ПАРСЕР С KEYWORD-BASED EXTRACTION
// ============================================

/**
 * Получить ручные переопределения данных банка из KV
 */
async function getManualOverride(env, bankName) {
  if (env.BANKS_DATA) {
    try {
      const override = await env.BANKS_DATA.get(`manual_override_${bankName}`, 'json');
      if (override) {
        return override;
      }
    } catch (error) {
    }
  }
  return null;
}

/**
 * Сохранить ручное переопределение данных банка в KV
 */
async function saveManualOverride(env, bankName, data) {
  if (env.BANKS_DATA) {
    await env.BANKS_DATA.put(`manual_override_${bankName}`, JSON.stringify(data));
    return true;
  }
  return false;
}

// ============================================
// СПЕЦИАЛИЗИРОВАННЫЕ ПАРСЕРЫ ДЛЯ КАЖДОГО БАНКА
// ============================================

/**
 * Парсер для Tasnim
 * @param {string} html - HTML content
 * @param {string} bankName - Bank name to determine tariff
 */
function parseTasnim(html, bankName = 'Tasnim') {
  const result = {
    markupRate: null,
    maxPrice: null,
    maxTerm: null,
    minDownPaymentRate: null,
    termRates: null
  };

  // Extract data from calculator sliders
  // <div class="section-calc__slider" id="goods-slider" data-min="10000" data-max="1000000"
  const goodsSliderMatch = html.match(/id="goods-slider"[^>]*data-min="([\d]+)"[^>]*data-max="([\d]+)"/);
  if (goodsSliderMatch) {
    result.maxPrice = parseInt(goodsSliderMatch[2]);
  }

  // <div class="section-calc__slider" id="duration-slider" data-min="3" data-max="12"
  const durationSliderMatch = html.match(/id="duration-slider"[^>]*data-min="([\d]+)"[^>]*data-max="([\d]+)"/);
  if (durationSliderMatch) {
    result.maxTerm = parseInt(durationSliderMatch[2]);
  }

  // Calculate minimum down payment rate from sliders
  // <div class="section-calc__slider" id="initial-payment-slider" data-min="2500" data-max="10000"
  const initialPaymentMatch = html.match(/id="initial-payment-slider"[^>]*data-min="([\d]+)"[^>]*data-max="([\d]+)"/);

  if (goodsSliderMatch && initialPaymentMatch) {
    const goodsMin = parseInt(goodsSliderMatch[1]); // 10000
    const paymentMin = parseInt(initialPaymentMatch[1]); // 2500
    result.minDownPaymentRate = paymentMin / goodsMin; // 0.25 (25%)
  }

  // Extract coefficients from window.cartTariffs JavaScript object
  const cartTariffsMatch = html.match(/window\.cartTariffs\s*=\s*\{([\s\S]+?)\};/);

  if (cartTariffsMatch) {
    const cartTariffsContent = cartTariffsMatch[1];

    // Determine which tariff to use based on bank name
    let tariffName = 'economy'; // default (lowest rates)

    // Check if bank name contains tariff indicator
    const bankNameLower = (bankName || '').toLowerCase();
    if (bankNameLower.includes('экспресс') || bankNameLower.includes('express')) {
      tariffName = 'express';
    } else if (bankNameLower.includes('стандарт') || bankNameLower.includes('standard')) {
      tariffName = 'standard';
    } else if (bankNameLower.includes('эконом') || bankNameLower.includes('economy')) {
      tariffName = 'economy';
    }

    // Extract the specific tariff's coefficients block
    // Pattern: tariffName: { conditions: "...", coefficients: { "1": 1.05, ... } }
    // Use a more specific pattern to match coefficients block with trailing comma/whitespace
    const tariffRegex = new RegExp(tariffName + ':\\s*\\{[^}]*coefficients:\\s*\\{([\\s\\S]*?)\\}\\s*\\}', 'i');
    const tariffMatch = cartTariffsContent.match(tariffRegex);

    if (tariffMatch) {
      const coefficientsBlock = tariffMatch[1];
      // Extract all coefficient entries like "6": 1.2712,
      const coefficientMatches = [...coefficientsBlock.matchAll(/"(\d+)":\s*([\d.]+)/g)];

      if (coefficientMatches.length > 0) {
        result.termRates = {};
        for (const match of coefficientMatches) {
          const term = parseInt(match[1]);
          const coefficient = parseFloat(match[2]);
          // Convert coefficient to markup rate: markup = coefficient - 1
          // e.g., coefficient 1.2712 = 27.12% markup for 6 months
          result.termRates[term] = coefficient - 1;
        }
      }
    }
  }

  return result;
}

/**
 * Парсер для ФинЛайт
 * @param {string} html - HTML content
 * @param {string} url - URL to fetch external JS files
 */
async function parseFinlight(html, url = null) {
  const result = {
    markupRate: null,
    maxPrice: null,
    maxTerm: null,
    minDownPaymentRate: null,
    termRates: null
  };

  // Extract from JSON in textarea: [{"lid":"...","li_name":"summa",...,"li_vmax":"300000",...}]
  // Extract summa (max price)
  const summaMatch = html.match(/\{"[^"]*":"[^"]*"[^}]*"li_name":"summa"[^}]*"li_vmax":"(\d+)"[^}]*\}/);
  if (summaMatch) {
    result.maxPrice = parseInt(summaMatch[1]);
  }

  // Extract vznos (down payment min) - ФинЛайт requires fixed 25% minimum down payment
  result.minDownPaymentRate = 0.25;

  // Extract term (max term)
  const termMatch = html.match(/\{"[^"]*":"[^"]*"[^}]*"li_name":"term"[^}]*"li_vmax":"(\d+)"[^}]*\}/);
  if (termMatch) {
    result.maxTerm = parseInt(termMatch[1]);
  }

  // Try to find external JS files that might contain calculator logic
  let jsContent = '';
  const jsFileMatches = [...html.matchAll(/<script[^>]*src=["']([^"']+\.js[^"']*)["']/gi)];

  for (const match of jsFileMatches) {
    let jsUrl = match[1];

    // Skip common libraries
    if (jsUrl.includes('jquery') || jsUrl.includes('bootstrap') || jsUrl.includes('analytics')) {
      continue;
    }

    try {
      // Convert relative URLs to absolute
      if (jsUrl.startsWith('//')) {
        jsUrl = 'https:' + jsUrl;
      } else if (jsUrl.startsWith('/') && url) {
        const urlObj = new URL(url);
        jsUrl = `${urlObj.origin}${jsUrl}`;
      } else if (!jsUrl.startsWith('http') && url) {
        const urlObj = new URL(url);
        const baseUrl = url.substring(0, url.lastIndexOf('/') + 1);
        jsUrl = baseUrl + jsUrl;
      }

      const jsResponse = await fetch(jsUrl);
      if (jsResponse.ok) {
        jsContent += await jsResponse.text() + '\n';
      }
    } catch (e) {
    }
  }

  // Look for rate configuration in JS content
  let annualPercent = null;

  if (jsContent) {
    // Try to find rate/percent configuration in JS
    const ratePatterns = [
      /(?:rate|percent|nazenka|markup)[:\s=]+(\d+(?:\.\d+)?)/gi,
      /["']percent["'][:\s]*(\d+(?:\.\d+)?)/gi,
      /data-percent=["'](\d+(?:\.\d+)?)["']/gi
    ];

    for (const pattern of ratePatterns) {
      const match = jsContent.match(pattern);
      if (match) {
        annualPercent = parseFloat(match[1]);
        break;
      }
    }
  }

  // Fallback: Extract annual percentage rate from HTML percent-start element
  // <div class='percent-start ...'><div class='tn-atom'>70</div></div>
  if (!annualPercent) {
    const percentMatch = html.match(/percent-start[^>]*>[\s\S]*?<[^>]*>(\d+(?:\.\d+)?)</);
    if (percentMatch) {
      annualPercent = parseFloat(percentMatch[1]);
    }
  }

  if (annualPercent && result.maxTerm) {
    // ФинЛайт calculation based on real data:
    // Example: 200k price, 50k down (150k financed), 6 months, 70% annual
    // Expected result: 32,069₽ markup → rate = 32,069 / 150,000 = 0.21379 (21.379%)
    // Formula: markup_rate = (annualPercent / 100) * (month / 12) * 0.61083
    // Verification: 0.70 * 0.5 * 0.61083 = 0.21379 ✓

    result.termRates = {};
    for (let month = 1; month <= result.maxTerm; month++) {
      // Calculate proportional rate with ФинЛайт's service fee adjustment
      const proportionalRate = (annualPercent / 100) * (month / 12);
      result.termRates[month] = proportionalRate * 0.61083;
    }
  }

  return result;
}

/**
 * Парсер для Kupitak
 */
function parseKupitak(html) {
  const result = {
    markupRate: null,
    maxPrice: null,
    maxTerm: null,
    minDownPaymentRate: null,
    termRates: null
  };

  // Kupitak fixed values
  result.maxPrice = 500000;  // Fixed max price for Kupitak
  result.minDownPaymentRate = 0.25;  // Fixed 25% minimum down payment

  // Extract max term from input max attributes
  // Look for smaller max values that represent months (likely < 100)
  const termInputMatches = [...html.matchAll(/<input[^>]*max=["']?(\d+)["']?[^>]*>/gi)];
  for (const match of termInputMatches) {
    const maxValue = parseInt(match[1]);
    // Term values are typically 1-12 months for Kupitak
    if (maxValue >= 1 && maxValue <= 24 && maxValue > (result.maxTerm || 0)) {
      result.maxTerm = maxValue;
    }
  }

  // Extract term-based markup rates from JavaScript
  // Pattern: if (thirdValue.val() == 1) { thirdValue.attr('data-nac', 13.44); }
  // We need to extract both data-nac (first calculator) and data-nac2 (second calculator)

  // Try to extract first calculator rates (data-nac)
  const nacPattern = /if\s*\([^)]*val\(\)\s*==\s*(\d+)\s*\)[^}]*attr\(['"]data-nac['"],\s*([\d.]+)\)/gi;
  const nacMatches = [...html.matchAll(nacPattern)];

  // Try to extract second calculator rates (data-nac2) as fallback
  const nac2Pattern = /if\s*\([^)]*val\(\)\s*==\s*(\d+)\s*\)[^}]*attr\(['"]data-nac2['"],\s*([\d.]+)\)/gi;
  const nac2Matches = [...html.matchAll(nac2Pattern)];

  // Use whichever has more matches, or prefer data-nac if equal
  const matches = nacMatches.length > 0 ? nacMatches : nac2Matches;

  if (matches.length > 0) {
    result.termRates = {};
    for (const match of matches) {
      const term = parseInt(match[1]);
      const rate = parseFloat(match[2]);
      // Convert percentage to decimal: 13.44 -> 0.1344
      result.termRates[term] = rate / 100;
    }
  }

  // Don't use markupRate since we use termRates
  result.markupRate = null;

  return result;
}

/**
 * Парсер для Al-Baraka
 * @param {string} html - HTML content
 * @param {string} bankName - Bank name to determine tariff (Идеал or Стандарт)
 * @param {string} url - URL to fetch external JS files
 */
async function parseAlBaraka(html, bankName = 'Al-Baraka', url = null) {
    const result = {
      markupRate: null,
      maxPrice: null,
      maxTerm: null,
      minDownPaymentRate: null,
      termRates: null
    };
  
    // --- 1. FIX: Define tariffName WITHOUT quotes ---
    // Define target name as a clean string (e.g., 'Идеал'), we will strip quotes from the scraped HTML later.
    let tariffName = 'Идеал'; // default (lowest rate)
    const bankNameLower = (bankName || '').toLowerCase();
  
    if (bankNameLower.includes('стандарт') || bankNameLower.includes('standart')) {
      tariffName = 'Стандарт';
    } else if (bankNameLower.includes('идеал') || bankNameLower.includes('ideal')) {
      tariffName = 'Идеал';
    }
  
    // Extract all tariff entries with their rates
    // Pattern: data-rate="0.02"><span>...<b>"Идеал"</b>
    const tariffEntriesPattern = /data-rate=["'](\d+\.?\d*)["'][^>]*>[\s\S]*?<b>([^<]+)<\/b>/gi;
    const tariffEntries = [...html.matchAll(tariffEntriesPattern)];
    let monthlyRate = null;
  
    // Find the matching tariff by name
    for (const entry of tariffEntries) {
      const rate = parseFloat(entry[1]);
      
      // --- 2. FIX: Strip all quote types (non-standard “”, and standard "") from the scraped name ---
      const rawName = entry[2].trim();
      // Regex [“”"'] removes non-standard quotes (“, ”), standard quotes ("), and single quotes (')
      const name = rawName.replace(/[“”"']/g, '');
  
      // Compare the cleaned name against the clean target name
      if (name === tariffName) {
        monthlyRate = rate;
        break;
      }
    }
  
    // Fallback: try to find first data-rate value if no match
    if (monthlyRate === null) {
      const anyRateMatch = html.match(/data-rate=["']?([\d.]+)["']?/);
      if (anyRateMatch) {
        monthlyRate = parseFloat(anyRateMatch[1]);
      }
    }
  
    const text = html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ');
  
    // --- Max Price and Max Term Extraction (Unchanged, remains robust) ---
    let jsContent = '';
    const jsFileMatch = html.match(/src=["']([^"']*assets\/js\/app\.js[^"']*)["']/i);
    if (jsFileMatch && url) {
      try {
        const urlObj = new URL(url);
        const jsUrl = `${urlObj.origin}/${jsFileMatch[1].replace(/^\//, '')}`;
        const jsResponse = await fetch(jsUrl);
        if (jsResponse.ok) {
          jsContent = await jsResponse.text();
        }
      } catch (e) {
      }
    }
  
    if (jsContent) {
      const calcSumSliderMatch = jsContent.match(/#calc-sum["']?\)\.slider\(\{[^}]*max:\s*(\d+)/i);
      if (calcSumSliderMatch) {
        result.maxPrice = parseInt(calcSumSliderMatch[1]);
      }
  
      const calcLenSliderMatch = jsContent.match(/#calc-len["']?\)\.slider\(\{[^}]*max:\s*(\d+)/i);
      if (calcLenSliderMatch) {
        result.maxTerm = parseInt(calcLenSliderMatch[1]);
      }
    }
  
    if (!result.maxPrice || !result.maxTerm) {
      const calcSumSliderMatch = html.match(/#calc-sum["']?\)\.slider\(\{[^}]*max:\s*(\d+)/i);
      if (calcSumSliderMatch) {
        result.maxPrice = parseInt(calcSumSliderMatch[1]);
      }
  
      const calcLenSliderMatch = html.match(/#calc-len["']?\)\.slider\(\{[^}]*max:\s*(\d+)/i);
      if (calcLenSliderMatch) {
        result.maxTerm = parseInt(calcLenSliderMatch[1]);
      }
    }
  
    if (!result.maxTerm) {
      const lenValMatch = html.match(/id=["']?len-val["']?[^>]*>(\d+)/i);
      if (lenValMatch) {
        result.maxTerm = parseInt(lenValMatch[1]);
      }
    }
  
    if (!result.maxPrice) {
      const sumValMatch = html.match(/id=["']?sum-val["']?[^>]*>(\d+)/i);
      if (sumValMatch) {
        result.maxPrice = parseInt(sumValMatch[1]) || 500000;
      }
    }
  
    // Calculate term rates based on monthly rate
    if (monthlyRate !== null && result.maxTerm) {
      result.termRates = {};
      for (let months = 1; months <= result.maxTerm; months++) {
        result.termRates[months] = monthlyRate * months;
      }
    }
  
    // Check for minimum down payment requirement - IMPROVED VERSION
    // Try multiple patterns to find minimum down payment in HTML/JS
    let foundMinDown = false;

    // Pattern 1: Search in text for "первоначальный взнос X%"
    const textPattern = text.match(/первоначальн[ыйая]+\s*(?:платеж|взнос)[^\d]*([\d.,]+)\s*%/i);
    if (textPattern) {
      result.minDownPaymentRate = parseFloat(textPattern[1].replace(',', '.')) / 100 || 0.25;
      foundMinDown = true;
    }

    // Pattern 2: Extract from first-pay element and divide by sum-val
    if (!foundMinDown && html) {
            
            // FIX 1: Extract first payment value from id="first-pay". 
            // Capture digits and spaces ([\d\s]+) within the span's content.
            // The space might be a regular space or a non-breaking space (which \s covers in many contexts).
            const firstPayMatch = html.match(/id\s*=\s*["']first-pay["'][^>]*>[\s\S]*?<span>([\d\s]+)<\/span>/i); 
            
            // FIX 2: Extract product cost from id="sum-val" content (Using the robust version from previous steps)
            const productCostMatch = html.match(/id\s*=\s*["']sum-val["'][^>]*>(\d+)<\//i);
      
            if (firstPayMatch && productCostMatch) {
              
              // Get the raw string and remove all non-digit characters (spaces, etc.)
              const rawFirstPayment = firstPayMatch[1].replace(/[^\d]/g, '');
              
              const firstPayment = parseInt(rawFirstPayment); // Will be 7895
              
              // The product cost (50000) is a single number so it doesn't need cleaning.
              const productCost = parseInt(productCostMatch[1]); // Will be 50000
              if (firstPayment > 0 && productCost > 0) {
                result.minDownPaymentRate = firstPayment / productCost <0.25 ? 0.25 : firstPayment / productCost;
                
                foundMinDown = true;
              }
            }
          }

    // Pattern 3: Search in HTML for slider/input min values related to down payment
    if (!foundMinDown && html) {
      const sliderPattern = html.match(/(?:взнос|payment|down)[\s\S]{0,200}data-min=["'](\d+)["']/i);
      if (sliderPattern) {
        const minValue = parseInt(sliderPattern[1]);
        if (minValue > 0 && minValue <= 100) {
          result.minDownPaymentRate = minValue / 100;
          foundMinDown = true;
        }
      }
    }

    // Pattern 4: Search for min down payment in JS variables or config
    if (!foundMinDown && (html || jsContent)) {
      const jsPatterns = [
        /(?:minDown|minPayment|минВзнос|minInitial)[:\s=]+(\d+)/i,
        /(?:взнос|downPayment)[\s\S]{0,100}min[:\s]*(\d+)/i,
      ];

      const searchContent = jsContent || html;
      for (const pattern of jsPatterns) {
        const match = searchContent.match(pattern);
        if (match) {
          const value = parseInt(match[1]);
          if (value > 0 && value <= 100) {
            result.minDownPaymentRate = value / 100;
            foundMinDown = true;
            break;
          }
        }
      }
    }

    // Pattern 5: Calculate from slider min/max values ratio if present
    if (!foundMinDown && html && result.maxPrice) {
      const initialSliderMatch = html.match(/(?:взнос|initial|down)[\s\S]{0,300}data-min=["'](\d+)["'][^>]*data-max=["'](\d+)["']/i);
      if (initialSliderMatch) {
        const minPayment = parseInt(initialSliderMatch[1]);
        const maxPayment = parseInt(initialSliderMatch[2]);
        if (result.maxPrice && minPayment > 100 && minPayment < result.maxPrice) {
          result.minDownPaymentRate = minPayment / result.maxPrice;
          foundMinDown = true;
        }
      }
    }

    // Check for "no down payment required" text AFTER trying all specific patterns
    // This ensures we prioritize calculator values over general text
    if (!foundMinDown && text.match(/не\s+нужно\s+вносить|без\s+первоначальн/i)) {
      result.minDownPaymentRate = 0;
      foundMinDown = true;
    }

    // If still not found, keep as null (will be handled by manual override or fallback)
    if (!foundMinDown) {
      result.minDownPaymentRate = null;
    }
  
    result.markupRate = null;
  
    return result;
  }

/**
 * Парсер для LaRiba
 * LaRiba использует внешние JS файлы для калькулятора
 * @param {string} html - HTML content
 * @param {string} url - URL to fetch external JS files
 */
async function parseLaRiba(html, url = null) {
  const result = {
    markupRate: null,
    maxPrice: null,
    maxTerm: null,
    minDownPaymentRate: null,
    termRates: null
  };

  const text = html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ');

  // 1. Поиск внешних JS файлов калькулятора
  // <script src="https://calc.lariba.ru/init-lariba-calculator.js"></script>
  // <script src="https://calc.lariba.ru/lariba-calculator_2.0.js"></script>
  const jsFiles = [];
  const jsFilePattern = /<script[^>]*src=["']([^"']*calc[^"']*)["']/gi;
  const jsMatches = [...html.matchAll(jsFilePattern)];

  for (const match of jsMatches) {
    let jsUrl = match[1];

    // Преобразуем относительные URL в абсолютные
    if (jsUrl.startsWith('//')) {
      jsUrl = 'https:' + jsUrl;
    } else if (jsUrl.startsWith('/')) {
      if (url) {
        const urlObj = new URL(url);
        jsUrl = `${urlObj.origin}${jsUrl}`;
      }
    } else if (!jsUrl.startsWith('http')) {
      if (url) {
        const urlObj = new URL(url);
        jsUrl = `${urlObj.origin}/${jsUrl}`;
      }
    }

    jsFiles.push(jsUrl);
  }

  // 2. Загружаем и парсим JS файлы
  let combinedJsContent = '';

  for (const jsUrl of jsFiles) {
    try {
      const jsResponse = await fetch(jsUrl);
      if (jsResponse.ok) {
        combinedJsContent += await jsResponse.text() + '\n';
      }
    } catch (e) {
    }
  }

  // 3. Извлечение данных из JS конфигурации
  if (combinedJsContent) {
    // LaRiba использует window.laRibaCalculatorRates с массивом тарифов
    // Ищем: window.laRibaCalculatorRates = { rates: [...] }
    const laRibaRatesPattern = /laRibaCalculatorRates\s*=\s*\{[\s\S]*?rates\s*:\s*\[([\s\S]*?)\]\s*\}/;
    const laRibaMatch = combinedJsContent.match(laRibaRatesPattern);

    if (laRibaMatch) {
      // Извлекаем все значения напрямую из полного контента
      let maxGoodsCost = 0;
      let maxPercentsLength = 0;
      let minInitialPayPercent = null;
      const allTermRates = {};

      // Извлекаем все maxGoodsCost
      const maxCostMatches = [...combinedJsContent.matchAll(/"maxGoodsCost"\s*:\s*(\d+)/g)];
      for (const match of maxCostMatches) {
        const cost = parseInt(match[1]);
        if (cost > maxGoodsCost) {
          maxGoodsCost = cost;
        }
      }

      // Извлекаем minInitialPayPercent (берем первый найденный)
      const minPayMatch = combinedJsContent.match(/"minInitialPayPercent"\s*:\s*(\d+)/);
      if (minPayMatch) {
        minInitialPayPercent = parseInt(minPayMatch[1]);
      }

      // Ищем начальный тариф (initialRate)
      const initialRateMatch = combinedJsContent.match(/"initialRate"\s*:\s*"([^"]+)"/);
      const initialRateName = initialRateMatch ? initialRateMatch[1] : null;

      // Извлекаем все тарифы с их названиями и массивами percents
      const tariffPattern = /\{\s*"name"\s*:\s*"([^"]+)"[\s\S]*?"percents"\s*:\s*\[([\d.,\s]+)\]/g;
      const tariffMatches = [...combinedJsContent.matchAll(tariffPattern)];

      let selectedTariff = null;

      for (const match of tariffMatches) {
        const tariffName = match[1];
        const percentsStr = match[2];
        const percentsArray = percentsStr.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));

        if (percentsArray.length > 0) {
          // Обновляем максимальную длину
          if (percentsArray.length > maxPercentsLength) {
            maxPercentsLength = percentsArray.length;
          }

          // Если это начальный тариф, используем его
          if (initialRateName && tariffName === initialRateName) {
            selectedTariff = percentsArray;
          }

          // Если нет начального тарифа, используем первый найденный или самый низкий
          if (!selectedTariff) {
            selectedTariff = percentsArray;
          } else if (!initialRateName) {
            // Сравниваем суммы для выбора самого низкого тарифа
            const currentSum = percentsArray.reduce((a, b) => a + b, 0);
            const selectedSum = selectedTariff.reduce((a, b) => a + b, 0);
            if (currentSum < selectedSum) {
              selectedTariff = percentsArray;
            }
          }
        }
      }

      // Создаем termRates из выбранного тарифа
      if (selectedTariff) {
        for (let i = 0; i < selectedTariff.length; i++) {
          const month = i + 1;
          const percent = selectedTariff[i];
          allTermRates[month] = percent / 100;
        }
      }

      if (maxGoodsCost > 0) {
        result.maxPrice = maxGoodsCost;
      }

      if (maxPercentsLength > 0) {
        result.maxTerm = maxPercentsLength;
      }

      if (minInitialPayPercent !== null) {
        result.minDownPaymentRate = minInitialPayPercent / 100;
      }

      if (Object.keys(allTermRates).length > 0) {
        result.termRates = allTermRates;
      }
    }

    // Fallback: общие паттерны если laRibaCalculatorRates не найден
    if (!result.maxPrice) {
      const maxPricePatterns = [
        /(?:maxSum|maxPrice|max_price|максСумма|maxAmount|maxGoodsCost)[:\s=]+(\d+)/gi,
        /(?:sum|price|amount).*?max[:\s]*(\d{5,})/gi,
        /max[:\s]*(\d{5,}).*?(?:sum|price|amount)/gi
      ];

      for (const pattern of maxPricePatterns) {
        const matches = [...combinedJsContent.matchAll(pattern)];
        for (const match of matches) {
          const value = parseInt(match[1]);
          if (!isNaN(value) && value > 50000 && value < 10000000) {
            result.maxPrice = value;
            break;
          }
        }
        if (result.maxPrice) break;
      }
    }

    if (!result.maxTerm) {
      // Ищем максимальный срок
      const maxTermPatterns = [
        /(?:maxTerm|maxMonth|max_term|максСрок|maxPeriod)[:\s=]+(\d+)/gi,
        /(?:term|month|period).*?max[:\s]*(\d{1,2})/gi,
        /max[:\s]*(\d{1,2}).*?(?:term|month|period)/gi
      ];

      for (const pattern of maxTermPatterns) {
        const matches = [...combinedJsContent.matchAll(pattern)];
        for (const match of matches) {
          const value = parseInt(match[1]);
          if (!isNaN(value) && value > 0 && value <= 60) {
            result.maxTerm = value;
            break;
          }
        }
        if (result.maxTerm) break;
      }
    }

    // Ищем наценку/процент
    const ratePatterns = [
      /(?:rate|percent|markup|наценка|процент)[:\s=]+([\d.]+)/gi,
      /(?:коэффициент|coefficient)[:\s=]+([\d.]+)/gi
    ];

    for (const pattern of ratePatterns) {
      const matches = [...combinedJsContent.matchAll(pattern)];
      for (const match of matches) {
        const value = parseFloat(match[1]);
        if (!isNaN(value)) {
          // Если значение больше 1, считаем процентом
          if (value > 1 && value < 200) {
            result.markupRate = value / 100;
            break;
          } else if (value > 0 && value <= 1) {
            result.markupRate = value;
            break;
          }
        }
      }
      if (result.markupRate) break;
    }

    // Ищем ставки по срокам в виде объектов или массивов ТОЛЬКО если еще не извлечены
    // Например: rates: {3: 0.15, 6: 0.20, 12: 0.25}
    // Или: [{term: 3, rate: 15}, {term: 6, rate: 20}]
    if (!result.termRates) {
      const termRatesObjPattern = /\{[\s\S]*?(?:["']?\d+["']?\s*:\s*[\d.]+[\s\S]*?){2,}\}/g;
      const termRatesMatches = [...combinedJsContent.matchAll(termRatesObjPattern)];

      for (const match of termRatesMatches) {
        const objStr = match[0];
        // Извлекаем пары ключ: значение
        const pairPattern = /["']?(\d+)["']?\s*:\s*([\d.]+)/g;
        const pairs = [...objStr.matchAll(pairPattern)];

        if (pairs.length >= 2) {
          const termRates = {};
          let validCount = 0;

          for (const pair of pairs) {
            const term = parseInt(pair[1]);
            const rate = parseFloat(pair[2]);

            if (!isNaN(term) && !isNaN(rate) && term > 0 && term <= 60) {
              // Определяем формат: процент или коэффициент
              if (rate > 1 && rate < 200) {
                termRates[term] = rate / 100;
                validCount++;
              } else if (rate > 0 && rate <= 1) {
                termRates[term] = rate;
                validCount++;
              }
            }
          }

          if (validCount >= 2) {
            result.termRates = termRates;
            result.markupRate = null;
            break;
          }
        }
      }
    }

    // Ищем минимальный взнос
    const minDownPatterns = [
      /(?:minDown|min_down|minPayment|минВзнос)[:\s=]+([\d.]+)/gi,
      /(?:первоначальн|initial)[:\s]+([\d.]+)/gi
    ];

    for (const pattern of minDownPatterns) {
      const match = combinedJsContent.match(pattern);
      if (match) {
        const value = parseFloat(match[1]);
        if (!isNaN(value)) {
          // Если больше 1, считаем процентом
          if (value > 1 && value <= 100) {
            result.minDownPaymentRate = value / 100;
            break;
          } else if (value >= 0 && value <= 1) {
            result.minDownPaymentRate = value;
            break;
          }
        }
      }
    }
  }

  // 4. Fallback: поиск в HTML тексте
  if (!result.maxPrice) {
    const maxPricePatterns = [
      /(?:максимальн[ао]+\s*сумм[аеы]|до)[^\d]*([\d\s]+)\s*(?:руб|₽)/i,
      /сумм[аеы][^\d]*(?:до|максимум)[^\d]*([\d\s]+)\s*(?:руб|₽)/i
    ];

    for (const pattern of maxPricePatterns) {
      const match = text.match(pattern);
      if (match) {
        const value = parseInt(match[1].replace(/\s/g, ''));
        if (!isNaN(value) && value > 50000 && value < 10000000) {
          result.maxPrice = value;
          break;
        }
      }
    }
  }

  if (!result.maxTerm) {
    const termPatterns = [
      /(?:рассрочк[аи]|срок)[^\d]*(?:до|на)\s*(\d{1,2})\s*мес/i,
      /(?:до|максимум)\s*(\d{1,2})\s*мес/i
    ];

    for (const pattern of termPatterns) {
      const match = text.match(pattern);
      if (match) {
        const value = parseInt(match[1]);
        if (!isNaN(value) && value > 0 && value <= 60) {
          result.maxTerm = value;
          break;
        }
      }
    }
  }

  if (!result.markupRate && !result.termRates) {
    const markupPatterns = [
      /(?:наценк[аи]|процент|ставк[аи]|маржа|переплат[аи])[^\d]*([\d.,]+)\s*%/i,
      /(\d{1,3}(?:[.,]\d+)?)\s*%[^\d]*(?:наценк|процент|ставк|маржа)/i
    ];

    for (const pattern of markupPatterns) {
      const match = text.match(pattern);
      if (match) {
        const value = parseFloat(match[1].replace(',', '.'));
        if (!isNaN(value) && value > 0 && value < 200) {
          result.markupRate = value / 100;
          break;
        }
      }
    }
  }

  if (result.minDownPaymentRate === null) {
    if (text.match(/без\s+(?:первоначальн|перв[ао]го|аванс|взнос)/i)) {
      result.minDownPaymentRate = 0;
    } else {
      const downPaymentPatterns = [
        /(?:первоначальн[ыйоая]+|перв[ыйао]+)\s*(?:взнос|платеж)[^\d]*([\d.,]+)\s*%/i,
        /(?:аванс|взнос)[^\d]*([\d.,]+)\s*%/i
      ];

      for (const pattern of downPaymentPatterns) {
        const match = text.match(pattern);
        if (match) {
          const value = parseFloat(match[1].replace(',', '.'));
          if (!isNaN(value) && value >= 0 && value <= 100) {
            result.minDownPaymentRate = value / 100;
            break;
          }
        }
      }
    }
  }

  return result;
}

/**
 * Парсер для Vatan
 */
function parseVatan(html) {
  const result = {
    markupRate: null,
    maxPrice: null,
    maxTerm: null,
    minDownPaymentRate: null,
    termRates: null
  };

  const text = html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ');

  // Extract JavaScript variables for Vatan's rate structure
  const obslujMatch = html.match(/var\s+obsluj\s*=\s*(\d+)/);
  const proc1Match = html.match(/var\s+proc1\s*=\s*(\d+)/);
  const proc2Match = html.match(/var\s+proc2\s*=\s*(\d+)/);
  const proc3Match = html.match(/var\s+proc3\s*=\s*(\d+)/);
  const proc4Match = html.match(/var\s+proc4\s*=\s*(\d+)/);
  const proc5Match = html.match(/var\s+proc5\s*=\s*(\d+)/);

  // Extract max price from form placeholder
  const maxPriceMatch = text.match(/max[:\s]*150[.\s]*000/i);
  if (maxPriceMatch) {
    result.maxPrice = 150000;
  }

  // Extract min down payment percentage
  const minDownMatch = text.match(/Первоначальный\s+взнос[^)]*от\s+(\d+)%/i);
  if (minDownMatch) {
    result.minDownPaymentRate = parseInt(minDownMatch[1]) / 100;
  }

  // Extract max term from select options
  const termOptionsMatch = html.match(/<option[^>]*value="(\d+)">(\d+)\s*мес/gi);
  if (termOptionsMatch && termOptionsMatch.length > 0) {
    const terms = termOptionsMatch.map(opt => {
      const match = opt.match(/value="(\d+)"/);
      return match ? parseInt(match[1]) : 0;
    });
    result.maxTerm = Math.max(...terms);
  }

  // Build term rates based on Vatan's pricing structure
  // They use fixed monthly fees per range + service fee
  if (proc1Match && proc2Match && proc3Match && proc4Match && proc5Match && obslujMatch) {
    const serviceFee = parseInt(obslujMatch[1]);
    const rate1 = parseInt(proc1Match[1]); // 500 per month for 5k-10k
    const rate2 = parseInt(proc2Match[1]); // 700 per month for 10k-20k
    const rate3 = parseInt(proc3Match[1]); // 1000 per month for 20k-30k
    const rate4 = parseInt(proc4Match[1]); // 1200 per month for 30k-40k
    const rate5 = parseInt(proc5Match[1]); // 42% annual for 40k+

    // For term-based rates, we need to calculate markup as a percentage
    // Vatan's formula: markup = (monthly_fee * term + service_fee) / financed_amount
    // We'll create a function that estimates rates for different price ranges

    // Use middle of each range for estimation
    const termRates = {};
    const maxTerm = result.maxTerm || 18;

    for (let term = 1; term <= Math.min(maxTerm, 18); term++) {
      // Use 40k+ range (42% annual) as it's most common
      // Formula: annual_rate / 12 * term = markup_rate
      const annualRate = rate5 / 100; // 0.42
      const monthlyRate = annualRate / 12;
      termRates[term] = monthlyRate * term;
    }

    result.termRates = termRates;
  }

  return result;
}

/**
 * Универсальный парсер (fallback)
 */
function parseGeneric(html) {
  const result = {
    markupRate: null,
    maxPrice: null,
    maxTerm: null,
    minDownPaymentRate: null,
    termRates: null
  };

  const text = html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ');

  // Общие паттерны
  const markupPatterns = [
    /наценк[аи][^\d]*([\d.,]+)\s*%/i,
    /процент[^\d]*([\d.,]+)\s*%/i,
    /ставк[аи][^\d]*([\d.,]+)\s*%/i,
    /маржа[^\d]*([\d.,]+)\s*%/i
  ];

  for (const pattern of markupPatterns) {
    const match = text.match(pattern);
    if (match) {
      const value = parseFloat(match[1].replace(',', '.'));
      if (!isNaN(value) && value > 0 && value < 100) {
        result.markupRate = value / 100;
        break;
      }
    }
  }

  const maxPriceMatch = text.match(/максимальн[ая]+ сумм[аи][^\d]*([\d\s]+)/i);
  if (maxPriceMatch) {
    const value = parseFloat(maxPriceMatch[1].replace(/\s/g, ''));
    if (!isNaN(value) && value > 10000) {
      result.maxPrice = value;
    }
  }

  const maxTermMatch = text.match(/(?:до|максимум)\s*([\d]+)\s*мес/i);
  if (maxTermMatch) {
    result.maxTerm = parseInt(maxTermMatch[1]);
  }

  const minDownMatch = text.match(/первоначальный взнос[^\d]*([\d.,]+)\s*%/i);
  if (minDownMatch) {
    result.minDownPaymentRate = parseFloat(minDownMatch[1].replace(',', '.')) / 100;
  }

  // Попытка найти таблицу ставок
  const termRatesPattern = /(\d+)\s*мес[^\d]*([\d.,]+)\s*%/gi;
  const termMatches = [...text.matchAll(termRatesPattern)];

  if (termMatches.length > 0) {
    const termRates = {};
    for (const match of termMatches) {
      const term = parseInt(match[1]);
      const rate = parseFloat(match[2].replace(',', '.'));
      if (!isNaN(term) && !isNaN(rate) && term > 0 && term <= 36 && rate > 0 && rate < 100) {
        termRates[term] = rate / 100;
      }
    }
    if (Object.keys(termRates).length > 0) {
      result.termRates = termRates;
      result.markupRate = null;
    }
  }

  return result;
}

/**
 * Выбор парсера в зависимости от банка
 */
async function selectParser(bankName, html, url = null) {
  const normalizedName = bankName.toLowerCase().trim();

  if (normalizedName.includes('tasnim')) {
    return parseTasnim(html, bankName);
  } else if (normalizedName.includes('финлайт') || normalizedName.includes('finlight')) {
    return parseFinlight(html);
  } else if (normalizedName.includes('kupitak') || normalizedName.includes('купитак')) {
    return parseKupitak(html);
  } else if (normalizedName.includes('baraka') || normalizedName.includes('барака')) {
    return await parseAlBaraka(html, bankName, url);
  } else if (normalizedName.includes('lariba') || normalizedName.includes('лариба')) {
    return await parseLaRiba(html, url);
  } else if (normalizedName.includes('vatan') || normalizedName.includes('ватан')) {
    return parseVatan(html);
  } else {
    // Fallback к универсальному парсеру
    return parseGeneric(html);
  }
}

/**
 * Получить HTML с учётом JavaScript редиректов и retry logic
 */
async function fetchHTML(url, retries = 3, initialDelay = 2000) {
  let lastError;

  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      // Add delay before retry attempts (but not on first attempt)
      if (attempt > 0) {
        const delay = initialDelay * Math.pow(2, attempt - 1); // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay));
      }

      const response = await fetch(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
          'Accept-Encoding': 'gzip, deflate, br',
          'DNT': '1',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1',
          'Sec-Fetch-Dest': 'document',
          'Sec-Fetch-Mode': 'navigate',
          'Sec-Fetch-Site': 'none',
          'Sec-Fetch-User': '?1',
          'Cache-Control': 'max-age=0'
        },
        cf: {
          cacheTtl: 3600,
          cacheEverything: true,
        }
      });

      if (!response.ok) {
        lastError = new Error(`HTTP ${response.status}`);

        // Only retry on 521, 522, 523, 524 (Cloudflare origin errors) and 503, 429
        if ([521, 522, 523, 524, 503, 429].includes(response.status) && attempt < retries - 1) {
          continue;
        }

        throw lastError;
      }

      let html = await response.text();

      // Проверяем на JavaScript редирект
      const jsRedirectMatch = html.match(/window\.location\.href\s*=\s*["']([^"']+)["']/);
      if (jsRedirectMatch) {
        const redirectPath = jsRedirectMatch[1];
        let redirectUrl;

        if (redirectPath.startsWith('http')) {
          redirectUrl = redirectPath;
        } else if (redirectPath.startsWith('/')) {
          const urlObj = new URL(url);
          redirectUrl = `${urlObj.origin}${redirectPath}`;
        } else {
          const urlObj = new URL(url);
          redirectUrl = `${urlObj.origin}/${redirectPath}`;
        }

        // Следуем редиректу
        const redirectResponse = await fetch(redirectUrl, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          }
        });

        if (redirectResponse.ok) {
          html = await redirectResponse.text();
        }
      }

      return html;

    } catch (error) {
      lastError = error;

      // If this is not the last attempt, continue to retry
      if (attempt < retries - 1) {
        continue;
      }
    }
  }

  // All retries failed, throw the last error
  throw lastError;
}

/**
 * Универсальная функция для автоматического парсинга HTML
 */
async function fetchAndParse(url, bankName, env) {
  try {
    // Проверяем наличие ручного переопределения
    const manualOverride = await getManualOverride(env, bankName);

    if (manualOverride) {
      return {
        ...manualOverride,
        lastUpdated: Date.now(),
        source: 'manual'
      };
    }

    // Получаем HTML с обработкой редиректов
    const html = await fetchHTML(url);

    // Используем специализированный парсер для банка
    const extracted = await selectParser(bankName, html, url);

    // Проверяем что хотя бы что-то извлечено
    const hasData = extracted.markupRate !== null ||
                    extracted.termRates !== null ||
                    extracted.maxPrice !== null;

    if (!hasData) {
      return null;
    }

    return {
      markupRate: extracted.markupRate,
      maxPrice: extracted.maxPrice !== null ? extracted.maxPrice : Infinity,
      maxTerm: extracted.maxTerm,
      minDownPaymentRate: extracted.minDownPaymentRate,
      termRates: extracted.termRates,
      lastUpdated: Date.now(),
      source: 'auto'
    };

  } catch (error) {
    return null;
  }
}

// ============================================
// УПРАВЛЕНИЕ ИСТОЧНИКАМИ БАНКОВ (ДИНАМИЧЕСКОЕ)
// ============================================

async function getBanksSources(env) {
  if (env.BANKS_DATA) {
    try {
      const sources = await env.BANKS_DATA.get('banks_sources', 'json');
      if (sources) {
        return sources;
      }
    } catch (error) {
    }
  }
  // Возврат пустой конфигурации если нет в KV (будет инициализировано при первом запросе)
  return { ingushetia: [], dagestan: [] };
}

async function saveBanksSources(env, sources) {
  if (env.BANKS_DATA) {
    await env.BANKS_DATA.put('banks_sources', JSON.stringify(sources));
    return true;
  }
  return false;
}

// ============================================
// ФУНКЦИЯ ОБНОВЛЕНИЯ ДАННЫХ
// ============================================

async function updateBanksData(env) {
  const updatedConfig = {
    ingushetia: [],
    dagestan: [],
    lastGlobalUpdate: Date.now(),
    failedBanks: [] // Список банков, для которых парсинг не удался
  };

  // Получаем динамические источники из KV или дефолтные
  const sources = await getBanksSources(env);

  // Helper function to add random delay (increased to avoid rate limiting and 521 errors)
  const randomDelay = () => new Promise(resolve => setTimeout(resolve, Math.random() * 3000 + 2000)); // 2-5 seconds

  // Обновление данных для Ингушетии
  for (const source of (sources.ingushetia || [])) {
    if (!source.enabled) continue;

    await randomDelay(); // Add delay between requests
    const parsedData = await fetchAndParse(source.url, source.name, env);

    if (parsedData) {
      updatedConfig.ingushetia.push({
        name: source.name,
        url: source.url,
        ...parsedData
      });
    } else {
      // Добавляем в список неудачных
      updatedConfig.failedBanks.push({
        name: source.name,
        region: 'ingushetia',
        reason: 'Parsing failed - manual override needed',
        timestamp: Date.now()
      });
    }
  }

  // Обновление данных для Дагестана
  for (const source of (sources.dagestan || [])) {
    if (!source.enabled) continue;

    await randomDelay(); // Add delay between requests
    const parsedData = await fetchAndParse(source.url, source.name, env);

    if (parsedData) {
      updatedConfig.dagestan.push({
        name: source.name,
        url: source.url,
        ...parsedData
      });
      console.log(`✓ Updated ${source.name} (source: ${parsedData.source || 'auto'})`);
    } else {
      // Добавляем в список неудачных
      updatedConfig.failedBanks.push({
        name: source.name,
        region: 'dagestan',
        reason: 'Parsing failed - manual override needed',
        timestamp: Date.now()
      });
    }
  }

  // Сохранение в KV storage
  if (env.BANKS_DATA) {
    await env.BANKS_DATA.put('current_config', JSON.stringify(updatedConfig), {
      expirationTtl: 86400 // Данные актуальны 24 часа
    });
  }

  return updatedConfig;
}

// ============================================
// ПОЛУЧЕНИЕ АКТУАЛЬНЫХ ДАННЫХ
// ============================================

async function getBanksConfig(env) {
  // Попытка получить данные из KV storage
  if (env.BANKS_DATA) {
    try {
      const storedData = await env.BANKS_DATA.get('current_config', 'json');
      if (storedData) {
        return storedData;
      }
    } catch (error) {
    }
  }

  return {
    ingushetia: [],
    dagestan: [],
    lastGlobalUpdate: null,
    failedBanks: []
  };
}

// ============================================
// РАСЧЁТ РАССРОЧКИ
// ============================================

function calculateInstallment(bank, price, downPayment, term) {
  if (bank.maxPrice !== null && bank.maxPrice !== undefined && price > bank.maxPrice) return null;
  if (term > bank.maxTerm) return null;
  if (downPayment < price * bank.minDownPaymentRate) return null;

  const financedAmount = price - downPayment;
  let markupValue;

  if (bank.termRates && bank.termRates[term]) {
    markupValue = financedAmount * bank.termRates[term];
  } else if (bank.markupRate !== null && bank.markupRate !== undefined) {
    markupValue = financedAmount * bank.markupRate;
  } else {
    return null;
  }

  const totalPayout = financedAmount + markupValue;
  const monthlyPayment = totalPayout / term;

  return {
    name: bank.name,
    url: bank.url,
    markup: Math.round(markupValue),
    totalCost: Math.round(downPayment + totalPayout),
    monthlyPayment: Math.round(monthlyPayment),
    note: (bank.maxPrice !== null && bank.maxPrice !== undefined && bank.maxPrice < Infinity) || bank.minDownPaymentRate > 0
      ? `Макс. сумма ${bank.maxPrice || 'не ограничена'}₽, макс. срок ${bank.maxTerm} мес., мин. взнос ${bank.minDownPaymentRate * 100}%`
      : null,
    lastUpdated: bank.lastUpdated
  };
}

// ============================================
// ОСНОВНОЙ ОБРАБОТЧИК ЗАПРОСОВ
// ============================================

async function handleRequest(request, env) {
  const url = new URL(request.url);

  // CORS headers
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS, DELETE, PUT',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Content-Type': 'application/json'
  };

  // Обработка preflight запроса
  if (request.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  // API endpoints
  if (url.pathname === '/api/calculate') {
    return handleCalculate(request, env, corsHeaders);
  }

  if (url.pathname === '/api/banks') {
    return handleBanksList(env, corsHeaders);
  }

  if (url.pathname === '/api/update') {
    return handleUpdate(env, corsHeaders);
  }

  if (url.pathname === '/api/health') {
    return new Response(JSON.stringify({ status: 'ok', timestamp: Date.now() }), {
      headers: corsHeaders
    });
  }

  // Admin endpoints для управления банками
  if (url.pathname === '/api/admin/banks/sources') {
    return handleAdminBanksSources(request, env, corsHeaders);
  }

  if (url.pathname === '/api/admin/banks/add') {
    return handleAdminAddBank(request, env, corsHeaders);
  }

  if (url.pathname === '/api/admin/banks/delete') {
    return handleAdminDeleteBank(request, env, corsHeaders);
  }

  if (url.pathname === '/api/admin/banks/toggle') {
    return handleAdminToggleBank(request, env, corsHeaders);
  }

  if (url.pathname === '/api/admin/override/set') {
    return handleAdminSetOverride(request, env, corsHeaders);
  }

  if (url.pathname === '/api/admin/override/get') {
    return handleAdminGetOverride(request, env, corsHeaders);
  }

  if (url.pathname === '/api/admin/override/delete') {
    return handleAdminDeleteOverride(request, env, corsHeaders);
  }

  // Debug endpoint to test parsing
  if (url.pathname === '/api/debug/parse') {
    return handleDebugParse(request, env, corsHeaders);
  }

  // Debug endpoint to check KV rates for Al-Baraka
  if (url.pathname === '/api/debug/kv-rates') {
    return handleDebugKVRates(env, corsHeaders);
  }

  // Endpoint not found
  return new Response(JSON.stringify({ error: 'Endpoint not found' }), {
    status: 404,
    headers: corsHeaders
  });
}

// ============================================
// ОБРАБОТЧИК РАСЧЁТА РАССРОЧКИ
// ============================================

async function handleCalculate(request, env, corsHeaders) {
  try {
    if (request.method !== 'POST') {
      return new Response(JSON.stringify({ error: 'Method not allowed' }), {
        status: 405,
        headers: corsHeaders
      });
    }

    const body = await request.json();
    const { region, price, downPayment, term } = body;

    // Валидация входных данных
    if (!region || !price || downPayment === undefined || !term) {
      return new Response(JSON.stringify({ error: 'Missing required parameters' }), {
        status: 400,
        headers: corsHeaders
      });
    }

    if (price <= 0 || downPayment < 0 || downPayment >= price || term <= 0) {
      return new Response(JSON.stringify({ error: 'Invalid parameter values' }), {
        status: 400,
        headers: corsHeaders
      });
    }

    // Получение актуальных данных
    const config = await getBanksConfig(env);
    const regionKey = region.toLowerCase() === 'ingushetia' ? 'ingushetia' : 'dagestan';
    const banks = config[regionKey] || [];

    // Проверка наличия данных
    if (banks.length === 0) {
      return new Response(JSON.stringify({
        success: false,
        error: 'no_data',
        message: 'Данные по банкам временно недоступны. Пожалуйста, попробуйте позже.',
        failedBanks: config.failedBanks || [],
        lastUpdate: config.lastGlobalUpdate,
        results: []
      }), {
        status: 200,
        headers: corsHeaders
      });
    }

    // Расчёт для каждого банка
    const results = banks
      .map(bank => calculateInstallment(bank, price, downPayment, term))
      .filter(result => result !== null);

    // Сортировка по итоговой стоимости
    results.sort((a, b) => a.totalCost - b.totalCost);

    // Информация о неудачных обновлениях
    const warnings = [];
    if (config.failedBanks && config.failedBanks.length > 0) {
      const regionFailed = config.failedBanks.filter(b => b.region === regionKey);
      if (regionFailed.length > 0) {
        warnings.push(`Данные некоторых банков недоступны: ${regionFailed.map(b => b.name).join(', ')}`);
      }
    }

    return new Response(JSON.stringify({
      success: true,
      region: region,
      results: results,
      warnings: warnings.length > 0 ? warnings : null,
      lastUpdate: config.lastGlobalUpdate,
      timestamp: Date.now()
    }), {
      headers: corsHeaders
    });

  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Internal server error',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// ============================================
// ОБРАБОТЧИК СПИСКА БАНКОВ
// ============================================

async function handleBanksList(env, corsHeaders) {
  try {
    const config = await getBanksConfig(env);

    return new Response(JSON.stringify({
      success: true,
      banks: {
        ingushetia: config.ingushetia.map(bank => ({
          name: bank.name,
          url: bank.url,
          maxPrice: bank.maxPrice,
          maxTerm: bank.maxTerm,
          minDownPayment: bank.minDownPaymentRate * 100,
          lastUpdated: bank.lastUpdated
        })),
        dagestan: config.dagestan.map(bank => ({
          name: bank.name,
          url: bank.url,
          maxPrice: bank.maxPrice,
          maxTerm: bank.maxTerm,
          minDownPayment: bank.minDownPaymentRate * 100,
          lastUpdated: bank.lastUpdated
        }))
      },
      failedBanks: config.failedBanks || [],
      lastUpdate: config.lastGlobalUpdate,
      timestamp: Date.now()
    }), {
      headers: corsHeaders
    });

  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Internal server error',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// ============================================
// ОБРАБОТЧИК РУЧНОГО ОБНОВЛЕНИЯ
// ============================================

async function handleUpdate(env, corsHeaders) {
  try {
    const updatedConfig = await updateBanksData(env);
    
    return new Response(JSON.stringify({
      success: true,
      message: 'Banks data updated successfully',
      stats: {
        ingushetia: updatedConfig.ingushetia.length,
        dagestan: updatedConfig.dagestan.length,
        failed: updatedConfig.failedBanks.length
      },
      failedBanks: updatedConfig.failedBanks,
      timestamp: updatedConfig.lastGlobalUpdate
    }), {
      headers: corsHeaders
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Update failed',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// ============================================
// SCHEDULED EVENT (CRON JOB)
// ============================================

async function handleScheduled(event, env) {
  console.log('Cron trigger: Starting scheduled update');
  await updateBanksData(env);
  console.log('Cron trigger: Update completed');
}

// ============================================
// ADMIN HANDLERS
// ============================================

// Получить список источников банков
async function handleAdminBanksSources(request, env, corsHeaders) {
  try {
    const sources = await getBanksSources(env);

    return new Response(JSON.stringify({
      success: true,
      sources: sources
    }), {
      headers: corsHeaders
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Failed to get banks sources',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// Добавить новый банк
async function handleAdminAddBank(request, env, corsHeaders) {
  try {
    if (request.method !== 'POST') {
      return new Response(JSON.stringify({ error: 'Method not allowed' }), {
        status: 405,
        headers: corsHeaders
      });
    }

    const body = await request.json();
    const { region, name, url, enabled = true } = body;

    if (!region || !name || !url) {
      return new Response(JSON.stringify({ error: 'Missing required fields' }), {
        status: 400,
        headers: corsHeaders
      });
    }

    const sources = await getBanksSources(env);

    // Добавляем новый банк
    if (!sources[region]) {
      sources[region] = [];
    }

    sources[region].push({
      name,
      url,
      enabled
    });

    await saveBanksSources(env, sources);

    return new Response(JSON.stringify({
      success: true,
      message: `Bank ${name} added successfully to ${region}`
    }), {
      headers: corsHeaders
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Failed to add bank',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// Удалить банк
async function handleAdminDeleteBank(request, env, corsHeaders) {
  try {
    if (request.method !== 'POST') {
      return new Response(JSON.stringify({ error: 'Method not allowed' }), {
        status: 405,
        headers: corsHeaders
      });
    }

    const body = await request.json();
    const { region, name } = body;

    if (!region || !name) {
      return new Response(JSON.stringify({ error: 'Missing region or name' }), {
        status: 400,
        headers: corsHeaders
      });
    }

    const sources = await getBanksSources(env);

    if (sources[region]) {
      sources[region] = sources[region].filter(bank => bank.name !== name);
      await saveBanksSources(env, sources);
    }

    return new Response(JSON.stringify({
      success: true,
      message: `Bank ${name} deleted from ${region}`
    }), {
      headers: corsHeaders
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Failed to delete bank',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// Включить/выключить банк
async function handleAdminToggleBank(request, env, corsHeaders) {
  try {
    if (request.method !== 'POST') {
      return new Response(JSON.stringify({ error: 'Method not allowed' }), {
        status: 405,
        headers: corsHeaders
      });
    }

    const body = await request.json();
    const { region, name, enabled } = body;

    if (!region || !name || enabled === undefined) {
      return new Response(JSON.stringify({ error: 'Missing required fields' }), {
        status: 400,
        headers: corsHeaders
      });
    }

    const sources = await getBanksSources(env);

    if (sources[region]) {
      const bank = sources[region].find(b => b.name === name);
      if (bank) {
        bank.enabled = enabled;
        await saveBanksSources(env, sources);
      }
    }

    return new Response(JSON.stringify({
      success: true,
      message: `Bank ${name} ${enabled ? 'enabled' : 'disabled'}`
    }), {
      headers: corsHeaders
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Failed to toggle bank',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// ============================================
// DEBUG HANDLER
// ============================================

async function handleDebugParse(request, env, corsHeaders) {
  try {
    const url = new URL(request.url);
    const testUrl = url.searchParams.get('url');
    const bankName = url.searchParams.get('bankName') || 'test';

    if (!testUrl) {
      return new Response(JSON.stringify({ error: 'Missing url parameter' }), {
        status: 400,
        headers: corsHeaders
      });
    }

    // Fetch the HTML with redirect handling
    const html = await fetchHTML(testUrl);

    // Try to extract data using bank-specific parser
    const extracted = await selectParser(bankName, html, testUrl);

    // Return debug info
    return new Response(JSON.stringify({
      success: true,
      url: testUrl,
      bankName: bankName,
      htmlLength: html.length,
      htmlPreview: html.substring(0, 1000),
      extracted: extracted,
      hasData: extracted.markupRate !== null || extracted.termRates !== null
    }), {
      headers: corsHeaders
    });

  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Debug failed',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// Debug handler to check KV rates
async function handleDebugKVRates(env, corsHeaders) {
  try {
    const config = await getBanksConfig(env);
    const alBarakaBanks = config.ingushetia.filter(bank =>
      bank.name.includes('Al-Baraka') || bank.name.includes('Барака')
    );

    const result = {};
    for (const bank of alBarakaBanks) {
      result[bank.name] = {
        maxPrice: bank.maxPrice,
        maxTerm: bank.maxTerm,
        minDownPaymentRate: bank.minDownPaymentRate,
        termRates: bank.termRates,
        lastUpdated: bank.lastUpdated,
        source: bank.source
      };
    }

    return new Response(JSON.stringify({
      success: true,
      alBarakaBanks: result,
      timestamp: Date.now()
    }), {
      headers: corsHeaders
    });

  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Failed to get KV rates',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// ============================================
// MANUAL OVERRIDE HANDLERS
// ============================================

// Установить ручное переопределение для банка
async function handleAdminSetOverride(request, env, corsHeaders) {
  try {
    if (request.method !== 'POST') {
      return new Response(JSON.stringify({ error: 'Method not allowed' }), {
        status: 405,
        headers: corsHeaders
      });
    }

    const body = await request.json();
    const { bankName, data } = body;

    if (!bankName || !data) {
      return new Response(JSON.stringify({ error: 'Missing bankName or data' }), {
        status: 400,
        headers: corsHeaders
      });
    }

    // Валидация данных
    const overrideData = {
      markupRate: data.markupRate !== undefined ? parseFloat(data.markupRate) : null,
      maxPrice: data.maxPrice !== undefined ? parseFloat(data.maxPrice) : null,
      maxTerm: data.maxTerm !== undefined ? parseInt(data.maxTerm) : null,
      minDownPaymentRate: data.minDownPaymentRate !== undefined ? parseFloat(data.minDownPaymentRate) : null,
      termRates: data.termRates || null
    };

    await saveManualOverride(env, bankName, overrideData);

    return new Response(JSON.stringify({
      success: true,
      message: `Manual override set for ${bankName}`
    }), {
      headers: corsHeaders
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Failed to set override',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// Получить ручное переопределение для банка
async function handleAdminGetOverride(request, env, corsHeaders) {
  try {
    const url = new URL(request.url);
    const bankName = url.searchParams.get('bankName');

    if (!bankName) {
      return new Response(JSON.stringify({ error: 'Missing bankName parameter' }), {
        status: 400,
        headers: corsHeaders
      });
    }

    const override = await getManualOverride(env, bankName);

    return new Response(JSON.stringify({
      success: true,
      bankName: bankName,
      override: override
    }), {
      headers: corsHeaders1
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Failed to get override',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// Удалить ручное переопределение для банка
async function handleAdminDeleteOverride(request, env, corsHeaders) {
  try {
    if (request.method !== 'POST') {
      return new Response(JSON.stringify({ error: 'Method not allowed' }), {
        status: 405,
        headers: corsHeaders
      });
    }

    const body = await request.json();
    const { bankName } = body;

    if (!bankName) {
      return new Response(JSON.stringify({ error: 'Missing bankName' }), {
        status: 400,
        headers: corsHeaders
      });
    }

    if (env.BANKS_DATA) {
      await env.BANKS_DATA.delete(`manual_override_${bankName}`);
    }

    return new Response(JSON.stringify({
      success: true,
      message: `Manual override deleted for ${bankName}`
    }), {
      headers: corsHeaders
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Failed to delete override',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}

// ============================================
// EVENT LISTENERS
// ============================================

export default {
  async fetch(request, env, ctx) {
    return handleRequest(request, env);
  },

  async scheduled(event, env, ctx) {
    await handleScheduled(event, env);
  }
};
